### Вопрос №1: Архитектура REST-сервиса

```
Опишите архитектуру REST-сервиса, который:
1. Получает параметры расчёта изделия
2. Вызывает функцию расчёта (локальную)
3. Сохраняет результат в базу (Postgres или ClickHouse)
4. Возвращает вычисленное значение клиенту
```

1. Структура проекта

```
project_root/
├── main.py                     # Точка входа в приложение
├── .env                        # Переменные окружения
├── env.example                 # Пример конфигурации для команды
├── docker-compose.yml          # Конфигурация контейнера
│
├── src/                        # Исходный код приложения
│   ├── api/                    # Роутеры с deps и handlers
│   ├── services/               # Слой бизнес-логики
│   ├── db/                     # Слой данных
│   │   ├── models/             # Модели базы данных
│   │   ├── repositories/       # Взаимодейсвтие с базой данных
│   │   └── session.py          # Сессии подключения к БД
│   ├── schemas/                # Pydantic модели / DTO
│   └── core/                   # Конфигурация и общие утилиты
└── tests/                      # Тесты
```

2. Где должна находиться бизнес-логика

Бизнес-логика должна находиться в папке services/.
Для того что бы следовать принципу разделения ответственности, упрощению тестирования, а так же переиспользования.

3. Как организовать конфигурацию (env)

Файл .env для хранения секретов и настроек, которые меняются от среды к среде (dev, prod).
Можно использовать как pydantic-settings так и свои классы с python-dotenv.

4. Как и чем логировать

Для логирования можно использовать как стандартный logging в чистом виде или своими обертками в json формате,
так и библиотеки по типу loguru.
Все логи выводятся в stdout откуда их забирает logstash/loki или же можно отсылать их в sentry.
После чего можно с помощью графаы наблюдать напримерз а кол-вом успешных и провальных операций и настроить уведомления.

5. Как обрабатывать ошибки (ошибки валидации / ошибки БД)

- Ошибки валидации перехватываются на уровне схемы Pydantic или Middleware 
и возвращает клиенту код ошибки (400/422) с описанием полей где произошла ошибка.
- Ошибки БД стоит отлавливать на уровне работы с бд с помощью встроенных exceptions для работы с бд, 
а клиенту лучше возвращать 500 или 503.


### Вопрос №2

```
Дана таблица расчётов коммерческих предложений:
quote_id material_id qty unit_cost unit created_at
5123 118 100 23.5 kg 2024-01-10
5123 118 0.1 2.35 ton 2024-01-10

Объясните:
1. Почему здесь есть проблема со стоимостью?
2. Как привести unit к единой системе?
3. Куда в архитектуре должен быть вынесен мэппинг единиц измерения — в код, БД, отдельную витрину?
4. Как убедиться, что новые данные не сломают консистентность?
```

1. Проблема со стоимостью в том, что в 1 строке цена за кг а во второй за тонну, 
при это за тонну тогда должна быть цена в 1000 раз больше чем за кг, 
либо ошибка в ручном вводе данных либо в не правильно или отсутствии валидации.

2. Необходимо выбрать базовую единицу измерения, создать справочник/маппинг и приводить все к базовой единице.

3. Маппинг должен храниться в бдд как отдельная таблица справочник. 

4. Как убедиться, что новые данные не сломают консистентность?
- использовать юнит тесты
- end-to-end тесты
- записи в справочнике должны быть уникальные для unit
- так же проверку входных данных на уровне api для разрешенных величин, 
например проверку, что тонна не может стоить дешевле килограмма.


### III. Написать один SQL-запрос, который возвращает 10 последних расчётов отсортированных по дате
```
SELECT 
    id,
    total_cost_rub,
    created_at
FROM calc_results
ORDER BY created_at DESC
LIMIT 10;
```